# ğŸ“˜ NollyAPI â€“ Official Documentation

Modular Kotlin API for modern Bukkit plugin development. Built with DSLs, clean architecture, and simplicity at heart.

---

## ğŸ”° Overview

**NollyAPI** is a modular, Kotlin-first Bukkit API for crafting clean, maintainable Minecraft plugins.

- ğŸ§© Fully modular (commands, events, items, GUI, network)
- ğŸ§™ DSL-driven (Kotlin idiomatic builder patterns)
- ğŸª„ Out-of-the-box listeners & managers
- â™»ï¸ Lifecycle-safe initialization
- ğŸ§  Written with ADHD-friendliness in mind: no bloat, just logic

---

## ğŸš€ Quickstart

### ğŸ“¦ Install

```kt
repositories {
	maven("https://nexus.thenolle.com/repository/nollyapi/") { name = "nollyapi" }
}

dependencies {
	implementation("com.thenolle.plugin:nollyapi:0.0.1@jar")
}
```

Check [Nexus](https://nexus.thenolle.com/#browse/browse:nollyapi) for latest version.

---

### ğŸ§¬ Setup in your Plugin

```kt
class MyPlugin : JavaPlugin() {
	override fun onEnable() {
		EventListener.init(this)
    GuiListener
    CustomItemListener
	}
}
```

---

## ğŸ§© Modules

### ğŸ§™ Commands â€“ `util.commands`

Register Bukkit commands declaratively via DSL, with built-in features like cooldowns, validation, tab completion, async support, and player-only checks.

```kt
command("hello") {
	description = "Greets the user"
	permission = "hello.use"
	
	execute {
		val target = argOrDefault(0, "world")
		sender.sendMessage("Hello, $target!")
	}
}
```

âœ¨ Highlights:

- ğŸ§  Argument parsing via `.arg<T>(index)`, `.argOrNull<T>()`, `.argOrDefault<T>()`
- ğŸ­ Auto-type parsing: `String`, `Int`, `Double`, `Boolean`, `Player`, `Enum`
- âš¡ Async handlers: `runAsync { ... }`
- ğŸ”’ Permission + message override
- âŒ Player-only enforcement: `requirePlayer()`
- ğŸ§ª Built-in validation logic (`validate { ... }`)
- ğŸ§Š Cooldowns with `cooldown(millis)`
- ğŸ“œ Tab suggestions (`suggest { ... }`, `.suggestPlayers()`, `.suggestEnum()`)
- ğŸ“š Subcommands via `.sub("subname") { ... }`
- ğŸ¤ Hidden commands, categories, custom usage

â¡ Components:

- `CommandBuilder.kt`: main DSL entry, executor logic
- `CommandDSL.kt`: `command(...)` wrapper
- `CommandContext.kt`: sender, label, args
- `CommandArgs.kt`: typed args, error messages, player checks
- `CommandCooldowns.kt`: cooldown logic
- `CommandRegistrar.kt`: Bukkit-level registration

ğŸ’¡ **Best practice**: keep command logic clean â€” push logic to services when complex.

---

### ğŸ§­ Events â€“ `util.events`

Handle **Bukkit & custom events** declaratively with a feature-rich, scope-aware DSL. Your listeners are readable, modular, and lifecycle-safe â€” perfect for modern plugins.

```kt
listen<PlayerJoinEvent> {
	it.player.sendMessage("Welcome, ${it.player.name}!")
}
```

âœ¨ **Key Features**

- ğŸ¯ **Scoped filters**: `scope { world("world_nether") }`, `.player("Nolly")`, `.permission("admin")`
- â± **Built-in modifiers**: `delay`, `debounce`, `throttle`, `once`, `ignoreCancelled`, `async`
- ğŸ§˜ **Suspend support**: `listenSuspend<T> { ... }`
- ğŸ§© **Group listeners** for batch unregistration (`EventGroup`)
- ğŸ§  **Metadata-aware** via `EventCustom` + `.meta(...)`
- ğŸ›‘ **Pause/resume logic** with `PauseManager`
- ğŸ” **Reusable filters** with `EventTemplates`
- ğŸª„ `JavaPlugin.on<T>()` sugar for inline use
- ğŸ§ª Test-friendly and predictable lifecycle

**Example: Scoped Async Listener**

```kt
listen<PlayerMoveEvent>(async = true, debounce = 100, scope = { world("world") }) {
	it.player.sendMessage("You're moving in the Overworld!")
}
```

**Example: Grouped Listeners**

```kt
val group = group {
	listen<PlayerJoinEvent> { ... }
	listen<PlayerQuitEvent> { ... }
}

group.unlistenAll() // easy cleanup!
```

â¡ Components:

- `EventDSL.kt`: DSL entrypoints: `listen`, `listenSuspend`, `plugin.on`, `EventGroup.listen`
- `EventScope.kt`: scoped filtering: `.player(...)`, `.permission(...)`, `.meta(...)`, `.paused(...)`
- `EventGroup.kt`: listener grouping
- `EventTemplates.kt`: reusable filter logic
- `EventCustom.kt`: custom events with `.meta` support
- `EventListener.kt`: low-level listener registration
- `PauseManager.kt`: pause/resume control
- `EventUtils.kt`: `fireEvent(...)`

ğŸ’¡ **Best practices**:

- ğŸ”„ Use `EventGroup` to manage mass listeners (especially for GUIs or sessions)
- ğŸ§  Leverage `.meta(...)` for custom state control across systems
- â›” Donâ€™t forget `EventListener.init(plugin)` in `onEnable`

---

- ### ğŸ§© Items â€“ `util.item`

	Create interactive, model-driven **custom items** with metadata, logic, variants, and GUI integration â€” all modular, scoped, and registry-backed.

	```kt
	val magicWand = SimpleItem("Â§5Magic Wand", Material.BLAZE_ROD)
		.lore("Â§7Right-click to cast a spell")
		.build("magic_wand")
		.onRightClick { it.sendMessage("âœ¨ Woosh!") }
	```

	âœ¨ **Core Features**

	- ğŸ” **All item types** return a `CustomItem` ready for interaction
	- ğŸ”’ **Metadata-tagged** via custom model data + lore
	- ğŸ§  Auto-registered on build (no boilerplate)
	- ğŸ§™ DSL-style builder chains for easy readability
	- ğŸª„ `.onClick`, `.onBlockBreak`, `.onEntityInteract`, `.onDrop`, `.openGuiOnRightClick`
	- âš™ï¸ Interaction breakdown: left/right, air/block, sneaking-aware
	- ğŸ’¬ Colorized `.color()` utility for lore/text
	- ğŸ“¦ Registry-based item command via `CustomItemCommand("ngive")`

	### ğŸ§ª Variants

	- ğŸ§± `SimpleItem`: For basic items with name, lore, glow, model data, etc.

	- ğŸª“ `ToolItem`: Attributes: `attackDamage`, `attackSpeed`, `durability`, `.unbreakable()`

	- ğŸ›¡ `ArmorItem`: Attributes: `armor`, `toughness`, `knockbackResistance`, `slot(...)`

	- ğŸ– `FoodItem`: Custom eat time, hunger, saturation, potion effects, post-consume conversion

	- ğŸ§ª `PotionItem`: Custom potion effects, colors, splash/lingering support

	**ğŸ“Ÿ Example: Registry Command**

	```kt
	// Automatically registered via init block
	CustomItemCommand("ngive")
	```

	```kt
	/ngive magic_wand [player]
	```

	- ğŸ§  Suggests IDs & online players

	- ğŸ” Supports permissions & custom usage messages

	â¡ Components:

	- `ItemBuilder.kt`: fluent base builder (used by all variants)
	- `CustomItem.kt`: event-rich, logic-wrapped item core
	- `CustomItemFactory.kt`: defines & instantiates items
	- `CustomItemRegistry.kt`: identifies items from metadata
	- `CustomItemCommand.kt`: `/ngive` logic
	- `CustomItemListener.kt`: interaction entrypoint
	- `CustomItems.kt`: defines + retrieves items by ID
	- `Color.kt`: `String.color()` formatting helper
	- `type/*Item.kt`: item variants (Simple, Tool, Armor, Food, Potion)

	ğŸ’¡ **Best practices**:

	- ğŸ”– Use `.build("id")` and register via `CustomItems.define(...)`
	- ğŸ§¼ Avoid putting logic in the builder â€” use `.onX()` to isolate behaviour
	- ğŸ§° Use `openGuiOnRightClick { ... }` for seamless GUI access

---

### ğŸªŸ GUI â€“ `util.gui`

Craft **interactive, animated inventory UIs** with fluent DSLs, metadata support, event hooks, redirection, and pagination.

```kt
gui(6, "Main Menu") {
	button(13) {
		item = myIcon
		onClick = { it.whoClicked.sendMessage("âœ¨ Clicked!") }
	}
}
```

âœ¨ **Core Features**

- ğŸ§  **Button logic** with throttle, debounce, delay, animation
- ğŸŒ€ **Item animations**: `.frames(...)`, `.interval(...)`
- ğŸ§© **Scope-aware interaction** via `EventScope<InventoryClickEvent>`
- ğŸ” **Redirection + metadata chaining** (`redirectTo(...)`, `chainRedirect(...)`)
- ğŸ—‚ **Templates**: reuse common buttons (`GuiBuilder.template(...)`)
- ğŸªª **Metadata per GUI + button**
- ğŸ›  **Custom event firing**: `GuiOpenEvent`, `GuiClickEvent`, `GuiCloseEvent`, `GuiRedirectEvent`

ğŸ§­ **Button Types**

```kt
button(12) {
	item = myIcon
	onClick = { player -> player.sendMessage("Clicked!") }
	delay = 20L
	debounce = 40L
	throttle = 500L
	scope = { player("Nolly") }
}
```

- `.redirectTo(from, to)`
- `.redirectToWithMeta(...)`
- `.chainRedirect(...)`
- `.setMeta(...)`, `.getMeta(...)`, `.hasMeta(...)`
- `.frames(...)` to animate the icon

ğŸ”€ **Redirection Logic**

```kt
button(11) {
	redirectTo(currentGui, nextGui)
}
```

- Keeps `"from"` and `"originalPage"` as metadata

- Works seamlessly with paginated UIs

- Fire `GuiRedirectEvent`

ğŸ§© **Templates**

```kt
GuiBuilder.template("back") {
	item = ItemStack(Material.ARROW).apply { ... }
	onClick = { player.closeInventory() }
}
```

```kt
gui(6, "Menu") {
	button(49, GuiBuilder.getTemplate("back")!!)
}
```

Supports `.override { ... }` to mutate templates per-use.

ğŸ“„ **Pagination**

```kt
PaginatedGuiBuilder.build("Items %page%", rows = 6, data = itemList) {
	slots(10, 11, 12, 13, 14)
	renderEach { gui, slot, item ->
		gui.button(slot) {
			this.item = item.toItemStack()
			onClick = { ... }
		}
	}
	nextButton(50) { paginated -> ... }
	previousButton(48) { paginated -> ... }
	pageIndicator(49)
}
```

- Automatic page logic
- Slots selection + `renderEach(...)`
- Navigation buttons with fallback display
- Supports `fillAll(...)`, `fillSlots(...)`, `border(...)`
- Dynamic titles via `titleFormatter { current, max -> ... }`

ğŸ”Œ **Events**

- `GuiOpenEvent`
- `GuiClickEvent`
- `GuiCloseEvent`
- `GuiRedirectEvent`

All are subclasses of `EventCustom`, so support `.meta(...)`.

â¡ **Components**:

- `GuiBuilder.kt`: Main builder + button DSL
- `PaginatedGuiBuilder.kt`: Page navigation, multi-page rendering
- `ButtonBuilder.kt`: DSL builder for GuiButton
- `GuiButton.kt`: Stateful clickable button with animation
- `GuiListener.kt`: Listens for GUI open/close/clicks
- `GuiRegistry.kt` Tracks open inventories
- `Gui*Event.kt`: Custom events with metadata support (Open, Close, Click, Redirect)

ğŸ’¡ **Best practices**:

- ğŸ§¹ Use templates for reusable buttons
- â›“ Use `.chainRedirect(...)` to maintain session metadata
- ğŸ›‘ Use `.scope { notPaused(...) }` to guard against invalid states
- ğŸ§ª Handle GUI transitions cleanly with `GuiRedirectEvent`

---

### ğŸ’¬ Messaging â€“ `util.msg`

Send rich, targeted, styled, and interactive messages with zero boilerplate.

âœ‰ï¸ **Message DSL**

```kt
message(sender) {
	success("Item given!")
	actionbar("&eUse it wisely.")
}
```

Or chain to players:

```kt
message(player, "&e[âš ]") {
	error("You cannot do that here.")
}
```

â¡ Automatically detects target (`Player`, `Console`, etc.)

ğŸ§  **Smart Filters**

```kt
message {
	filter { it.isOp }
	hasPermission("admin.access")
	isNamed("Nolly")
	hasGamemode(GameMode.CREATIVE)
	isInWorld("world")
	add("Only visible to qualified players.")
	send()
}
```

You control **who sees what**, easily.

ğŸ“š **Hover & Click Text**

```kt
hoverable("&aClick here") {
	tooltip("&7Gives you a &aMagic Wand")
	onClickCommand("/ngive magic_wand")
}
```

Or with `.append(...)` for compound components:

```kt
message(player) {
	add("Get your ")
	add(hoverable("&bSword") {
		tooltip("&7A legendary blade")
		onClickCommand("/ngive sword")
	})
	send()
}
```

âœ… **Standard Messages**

- `chat("...")`: Prefixed chat
- `success("...")`: Green âœ” success
- `error("...")`: Red âŒ error
- `actionbar("...")`: Action bar message
- `title("...")`: Title + optional subtitle
- `bossBar("...")`: Returns a `BossBar` with color/style

ğŸ”„ Add placeholders via:
```kt
val msg = placeholder("&aHello %0%!", "Nolly")
val msg2 = placeholder("&aHello %name%!", mapOf("name" to "Nolly"))
```

ğŸ“¢ **Broadcasts**

```kt
broadcast {
	success("Server restarted!")
}

broadcastActionbar("&eâš  Restart in 30s!")
broadcastBossBar("&cThe world is collapsing!", BarColor.RED)
```

Or with a prefix:

```kt
broadcast("&6[Server]") {
	error("This world is deprecated.")
}
```

### ğŸ’¡ Best practices

- ğŸ§¼ Use `message(...)` everywhere instead of raw `sendMessage`
- ğŸ§  Keep hover/click logic out of commands â€“ define via `HoverTextBuilder`
- âœ… Always use `.success()` and `.error()` for UX clarity
- ğŸš« Avoid mixing broadcast + direct logic unless you need it

â¡ **Components**

- `MessageBuilder.kt`: Core fluent message builder
- `HoverTextBuilder.kt`: Hover/click DSL
- `MessageDSL.kt`: Extension shortcuts for player/command/message dispatch
- `MessageColor.kt`: `&x` â†’ `Â§x` color translator
- `HoverTextDSL.kt`: `hoverable(...)` DSL wrapper
- `Message.kt`: Entrypoint factory

---

### ğŸŒ Web Framework â€“ `util.web`

#### ğŸ’  **Core Philosophy**

- ğŸ’¡ Expressive `WebContext` for all request data
- ğŸ§° Generic `ApiResponse<T>` for success/error JSONs
- ğŸ§± Route builders with middleware support
- ğŸ” Easy CORS & middleware setup
- ğŸ“¦ Typed routes (auto-deserialization for POST/PUT/...)
- ğŸ”Œ WebSocket sessions with `.emit`, `.on`, `joinRoom`

#### ğŸ“¦ HTTP â€“ `WebRouter`, `WebContext`

ğŸŒˆ **Example Usage:**

```kt
val api = WebRouter("/api")

api.get("/hello") {
	val name = param("name") ?: "world"
	json(mapOf("message" to "Hello, $name!"))
}
```

ğŸ”„ **DSL Highlights**

```kt
api.post("/login") {
	val username = param("user")
	val header = header("Authorization")
	val body = body<LoginRequest>() // auto-deserialized
}
```

- `param(key)` â†’ from path or query
- `body<T>()` â†’ auto-decodes JSON into `T`
- `json(data)` / `error(msg)` / `ok()`
- HTTP method checks: `.isPost()`, `.isGet()` etc.

#### ğŸ§° `WebRouter` Features

- `get`, `post`, `put`, `patch`, `delete`, `options`, `head`
- Middleware via `.use(...)` or `.useNamed(...)`
- Global middleware with `.use(...)` on router
- Type-safe routes via `postTyped<T> { }`
- JSON decoding via kotlinx serialization
- Built-in status handling via `StatusPages`

**ğŸ”¥ Example: Typed Route**

```kt
data class Login(val email: String, val password: String)

api.postTyped<Login>("/login") {
	val data = it
	if (data.password != "admin") error("Wrong password")
	else json(mapOf("message" to "Welcome ${data.email}"))
}
```

#### ğŸ§± Middleware

ğŸŒ **Custom Middleware Interface**

```kt
val logging = object : WebMiddleware {
	override val name = "logger"
	override suspend fun handle(call, next) {
		println("${call.request.uri}")
		next()
	}
}
```

Use it like:

```kt
api.use(logging)
```

Or per-route:

```kt
api.get("/data") {
	use(logging)
	handle {
		json("secured data")
	}
}
```

#### ğŸ”„ `ApiResponse<T>`

Standard format for responses:

```json
{
  "success": true,
  "data": { ... }
}
```

```json
{
  "success": false,
  "error": "Something went wrong"
}
```

Used in exception handler, `.error(...)`, and `.json(...)`.

#### ğŸ–¥ Static Assets & CORS

```kt
staticFolder("/files", "data/uploads")
staticResources("/res", "public")
staticAssets("/static") {
	folder("web")
}
```

```kt
cors {
	defaultCorsConfig()
	allowHost("cafe.thenolle.com", schemes = listOf("https"))
}
```

---

### ğŸ“¡ WebSockets â€“ `util.web.socket`

âœ… Features:

- ğŸ”„ `emit(event, data)`
- ğŸ“¬ `on(event)`
- ğŸ“ `join(room)` / `leave()`
- ğŸ§  `onAny`, `.emitAck`, `.onTyped(...)`
- ğŸ§ Middleware for sessions
- ğŸ› Graceful close via `.onClose { ... }`

```kt
socket("/ws") {
	use { println("Connected: ${host}") }

	onConnect {
		emit("hello", "Welcome!")
	}

	on("ping") {
		send("pong")
	}

	onTyped<Login> ("login") { login ->
		username = login.email
		join("staff")
	}
}
```

#### ğŸ“¡ `SocketRegistry`

Global utilities:

- `.broadcast(...)`
- `.emitToUsername(...)`
- `.broadcastRoom(...)`
- `.broadcastExcept(...)`

ğŸ§ª SocketSession Cheatsheet

| Method            | Description                  |
| ----------------- | ---------------------------- |
| `emit("x", data)` | Send event to client         |
| `on("x") {}`      | Listen to client events      |
| `onTyped<T>() {}` | Deserialize JSON into Kotlin |
| `join("room")`    | Join broadcast group         |
| `leave()`         | Leave current room           |
| `close("bye")`    | Gracefully disconnect client |

## ğŸ’¡ Best Practices

- âœ… Use `WebContext` in all handlers â†’ consistent, clean code
- ğŸ§  Centralize `ApiResponse<T>` usage for client reliability
- ğŸ§© Use `typed` routes when working with structured bodies
- ğŸ›‘ Avoid `GlobalScope` except in registry; use structured coroutines in services
- ğŸ’¬ Use `.emitAck(...)` to track client acks via timeout

---

## ğŸ“‚ File Structure

```bash
nollyapi/
â”œâ”€â”€ NollyAPI.kt              # Plugin entry
â””â”€â”€ util/
    â”œâ”€â”€ commands/            # Command DSL
    â”œâ”€â”€ events/              # Event DSL & infra
    â”œâ”€â”€ gui/                 # Custom gui DSL
    â”œâ”€â”€ item/                # Custom item DSL & infra
    â””â”€â”€ web/                 # Custom web DSL & infra
```

---

### ğŸ›Ÿ Contributing

1. Fork [GitHub](https://github.com/nollyscafe/nollyapi)
2. Write idiomatic Kotlin (no nulls, no bloat)
3. PR with context + text case

---

## ğŸ“– Tutorials

See `/tutorials` or [GitHub â†’ Tutorials](https://github.com/nollyscafe/nollyapi/tree/master/tutorials)

---

## ğŸ“Œ Metadata

- Author: Nolly Berrebi ([@NollysCafe](https://github.com/nollscafe))
- License: [NFE-OSL v1.0](https://cafe.thenolle.com/nfe-osl)
- Kotlin: [2.1.20](https://kotlinlang.org/)
- API: [Spigot/Bukkit 1.21+](https://helpch.at/docs/1.21/)